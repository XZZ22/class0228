<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>对象的深度克隆</title>
</head>
<body>
<!--
  1、数据类型：
    * 数据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型
    - 基本数据类型：
      特点： 存储的是该对象的实际数据
    - 对象数据类型：
      特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里
  2、复制数据
    - 基本数据类型存放的就是实际的数据，可直接复制
      let number2 = 2;
      let number1 = number2;
    - 克隆数据：对象/数组
      1、区别： 浅拷贝/深度拷贝
         判断： 拷贝是否全部产生了新的数据还是拷贝的是数据的引用
         知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用
         let obj = {username: 'kobe'}
         let obj1 = obj; // obj1 复制了obj在栈内存的引用
      2、常用的拷贝技术
        1). arr.concat(): 数组浅拷贝
        2). arr.slice(): 数组浅拷贝
        3). JSON.parse(JSON.stringify(arr/obj)): 数组或对象深拷贝, 但不能处理函数数据
        4). 浅拷贝包含函数数据的对象/数组
        5). 深拷贝包含函数数据的对象/数组
-->
<script type="text/javascript">
  // let person1 = {name: '吴杰', age: 23, sex: {option1: '男', option2: '女'}};
  // let person2 = person1;  //浅度克隆，修改克隆出来的对象，原对象也会产生影响
  // person2.age = 24;
  // person2.sex.option3 = '不男不女';
  // console.log(person1);
  // let person2 = {};
  // Object.assign(person2, person1);  //浅度克隆, 能够复制一般数据类型，不会影响原对象，但是一旦复制引用数据类型，会影响原对象
  // person2.age = 24;
  // person2.sex.option3 = '不男不女';
  // console.log(person1);

  //concat()
  /*let arr1 = [1, 2, {name: '吴杰'}];
  let arr2 = [];
  // console.log(arr2.concat(arr1));
  // console.log(arr2);
  arr2 = arr2.concat(arr1);  //浅度克隆
  arr2[2].name = '吴俊杰';
  console.log(arr1);*/

  //slice()
  /*let arr1 = [1, 2, {name: '吴杰'}];
  let arr2 = arr1.slice();  //浅度克隆
  arr2[2].name = '吴俊杰';
  console.log(arr1);*/

  //深度克隆
  /*let person1 = {name: '吴杰', age: 23, sex: {option1: '男', option2: '女'}};
  let arr1 = [1, 2, {name: '吴杰'}];
  //能够实现对象和数组的深度克隆
  let json = JSON.stringify(arr1);
  let arr2 = JSON.parse(json);
  console.log(arr1, arr2);
  arr2[2].name = '吴俊杰';
  console.log(arr1, arr2);*/

  // let json = JSON.stringify(person1);
  // let person2 = JSON.parse(json);
  // console.log(person1, person2);
  // person2.age = 24;
  // person2.sex.option3 = '不男不女';
  // console.log(person1, person2);

  /*function Test() {

  }
  Test.prototype.name = 'Test';
  let t = new Test();

  function fn() {

  }

  let person = {
    a: Test,
    b: t,
    c: /^123$/,
    d: fn
  }
  /!*
    方法存在局限性：
      函数不能被转化为json字符串
      正则表达式会被转化为空的对象
      自己new构造函数创建的实例对象原型上的方法不能复制成功
   *!/
  let json = JSON.stringify(person);
  console.log(json);
  let person1 = JSON.parse(json);
  console.log(person1);*/

  //如何区分所有数据类型？？？
  console.log(Object.prototype.toString.call({}).slice(8, -1));
  console.log(Object.prototype.toString.call([]).slice(8, -1));
  console.log(Object.prototype.toString.call(function () {

  }).slice(8, -1));
  console.log(Object.prototype.toString.call(123).slice(8, -1));
  console.log(Object.prototype.toString.call(true).slice(8, -1));
  console.log(Object.prototype.toString.call(null).slice(8, -1));
  console.log(Object.prototype.toString.call(undefined).slice(8, -1));



</script> 
</body>
</html>